\section{Implementation}
    crucial arithmetic
    How it works together
    Reference ideas (Maybe from litterature)
    - Explain how you got th idea
    - Did you get the idea from somewhere else, explain it from where

~10 pages

This section will describe how the reference implemenation from Bernstein was ported, and how the Karatsuba algorithm is implemented in practice.
\subsection{Reference implementation}
The reference implementation was straight forward to port, as the arithmetic itself could be used directly without any changes.


The \texttt{checksum\_compute} function used the \texttt{random\(\)} function given in the C standard libary to fill \texttt{p} and \texttt{n} with random values. In the main implementation \texttt{randombytes\(\)} is used to fill \texttt{p} and \texttt{n} with random values, as \texttt{randombytes\(\)} is supplied with the implementation from the rainbowgit\citeimplemenation]{rainbowgit}, 
As the C standard libary is not available an alternative to the \texttt{random\(\)} function is used. The library rainbowgit\cite{rainbowgit} is used for the \texttt{randombytes\(\)} implemenation, this implementation uses \texttt{AES} to give a pseudorandom output. As \textit{AES} isnt supplied either, the libcrypto\citelibrary]{libcrypto}, it can be found in \textit{src/libcrypto}. It is maintained by the official RISC-V organization, and is actively being developed.



\subsection{Karatsuba algorithm}


\subsection{Testing}
I wanted to be able to test the code with different values, without having to recompile and restart the emulation every time. The \textit{HAL} library implements a series of serial-functions. Which allows the code to communicate with the host.
\subsubsection{Device}
The embeded device is waiting for the host to send a command, which it acts on. It has 5 different modes that the host can use. 
\lstinputlisting[language=c, firstline=19, lastline=23]{../src/test.c}

\textbf{MODE\_BLANK} is the default mode. When the device is in \textit{MODE\_BLANK} it waits for a new mode from the host.\\
\lstinputlisting[language=c, firstline=115, lastline=121]{../src/test.c}
\textbf{MODE\_HASH} initializes the \textit{m} and \textit{n} memory with random values, and times the amount of cycles it takes to run \texttit{crypto\_scalarmult\_base}. Then sends the \textit{checksum} and \textit{cycles} to the host.\\ 
\lstinputlisting[language=c, firstline=85, lastline=97]{../src/test.c}

\textbf{MODE\_SEED} takes 48 integers, which is put into the seed memory space, and then the seed is set with \textit{randombytes\_init}.\\
\lstinputlisting[language=c, firstline=105, lastline=110]{../src/test.c}

\textbf{MODE\_PING} is used as part of the initializion of the connection with the test-script on the host. When the host connects to the serial port it sends a \textit{MODE\_PING} command and waits for a reply to ensure the device is listening.\\
\lstinputlisting[language=c, firstline=100, lastline=102]{../src/test.c}

\textbf{MODE\_SET\_KARAT} sets \textit{KARAT\_L} which defines the length of the numbers when the Karatsuba algorithm should use schoolbook multiplication.\\
\lstinputlisting[language=c, firstline=113, lastline=113]{../src/test.c}

\subsubsection{Host}
On the host a test script to connect to the device was written. The script is made in NodeJS\cite{nodejs}, and uses the library SerialPort\cite{serialport} to establish a connection and communicate with the device.
A wrapper function is written to convert the function \textit{port.write(msg, callback)} into a \textit{async} function. 
\lstinputlisting[language=javascript, firstline=15, lastline=18]{../test/index.js}

When the connection is opened, the \textit{MODE\_PING} command is sent to the device.\\
\lstinputlisting[language=javascript, firstline=20, lastline=22]{../test/index.js}

As the data from the embeded device is sent in chunks the script needs to be able to detect when a message has been fully recieved. As a message always ends with \texttt{\}} and then \textit{,} the script will look for thoose two characters to detect when a message has been fully recieved.
\lstinputlisting[language=javascript, firstline=1, lastline=29]{../test/helpers.js}
The \textit{dataParser} function copies every part of a string into a temporary string, and checks the condition described above. If the message has been recived it will return a \textit{JSON} object, otherwise it will return \textit{false}.

The function \texttt{dataParser} is called when data is recieved, and only acted upon if if returns a object.  
\lstinputlisting[language=javascript, firstline=28, lastline=31]{../test/index.js}
The exsistance of keys on the message object, is used to check what kind of message it is.

A \textbf{ping} message is recieved in response to the \textbf{MODE\_PING} sent when the connection is opened. This automaticly sets the seed and starts a hash.

The \textbf{checksum} message is recieved when a hash iteration is successfull, which just prints out the message and replies with the \textbf{MODE\_HASH} mode.

If the variable \textit{karaI} is set to a number, then it tries to iterates over all "breaking" points for what length to use the schoolbook multiplication instead of the Karatsuba algorithm. It does this by waiting for \textbf{ping} and \textbf{checksum} messages, and trying every value up until 64, and saving the cycles result for every value.
\lstinputlisting[language=javascript, firstline=34, lastline=55]{../test/index.js}